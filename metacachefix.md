Текущая реализация (в rueidis.go) использует функцию txnWithWriteBack.
Но она выполняет транзакцию в Redis сначала (вызов m.txn(ctx, txf, keys...)), и только после этого создаёт oplog (в виде списка ключей, без значений), сохраняет его в локальную БД (Badger) и кладёт в m.oplogQueue.
Фоновый воркер runSyncWorker читает m.oplogQueue и вызывает syncOplog, который пытается повторно применить операции к Redis.
Проблемы и последствия:
oplog, который сохраняется сейчас, содержит только ключи (тип "set" без Value) — коммент в коде прямо говорит, что «в полном варианте надо бы получить новое значение из Redis», но этого не сделано. Поэтому синк может испортить данные (попытка записать пустые значения) или ничего полезного не сделать.
Потому фактически мы НЕ делаем «write-back first»: запись идёт в Redis синхронно, потом мы лишь записываем «информационный» oplog. Это даёт мало преимуществ для мелких записей — задержка остаётся из-за сетевого обращения к Redis.
Пайплайнинг/батчинг для групповой отправки oplog'ов сейчас ещё не реализован (частично есть механизмы batchQueue и batch flusher, но они для другой ветки — batch* для batch write; oplog-синк в runSyncWorker просто посылает по одному oplog'у).
Вывод: текущая реализация не соответствует ожиданию «локальная транзакция → запись в лог → объединение логов в одну транзакцию и единоразовая отправка в Redis».

Что нужно сделать, чтобы реализовать желаемое поведение (пошагово)

Дать транзакции возможность работать «локально сначала». Т.е. при вызове мета-операции:
выполнить транзакцию в локальном Badger (через m.localCache.txn) при помощи обёртки recordingTxn, которая:
применяет все операции локально (set/delete/incrBy/append и т.д.)
одновременно собирает эти операции в структуру metaOplog (включая значения и поля для HSET)
записать сериализованный metaOplog в Badger (persist)
поставить metaOplog в m.oplogQueue (или в буфер для батчинга) — возвратить управление вызывающему (write-back semantics).
Фоновой sync worker должен:
собирать несколько oplog'ов (или несколько операций из oplog'ов) в пачку (pipelining), оптимизировать (склеивать HSET в HMSET, coalesce INCRBY, MSET для ключей), и отправлять одной операцией в Redis (используя Rueidis pipelining/transactions).
при успешной отправке — удалять соответствующие oplog'ы из Badger (или помечать).
при конфликте/ошибке — откладывать retry и/или переключать на режим «read-only» при серьёзных ошибках сети.
Небольшие технические изменения в коде:
расширить metaOp структурой, чтобы хранить Field (для HSET) и Value (для HSET/SET) — сейчас Value есть, но Field нет;
реализовать адаптер, который выступает в роли rueidiscompat.Tx, но делает запись в recordingTxn при локальной транзакции (или отдельно вызывать txf с прокси-интерфейсом);
заменить txnWithWriteBack на версию, которая при включённом fast-meta делает локальную транзакцию + сохранение oplog, вместо «Redis-first».
реализовать батч-сборку и отправку в runSyncWorker (или отдельный batchSyncWorker) с использованием Rueidis pipeline/MULTI/EXEC при необходимости.
Минимальный безопасный план изменений (реализация по шагам)

Шаг A (малый, безопасный, тестируемый):
Изменить txnWithWriteBack так, чтобы он:
выполнял локальную транзакцию и собирал metaOplog (через recordingTxn),
сохранял metaOplog в Badger и ставил в m.oplogQueue,
НО НЕ удалял/не менял поведение текущих мест вызова (временно не трогаем m.txn(ctx, txf, keys...) — нужно изменить код вызовов, либо писать прокси-тx).
Добавить простую обработку в runSyncWorker — на чтении oplog отправлять набор операций в Redis используя простую последовательность команд (без WATCH пока) — чтобы увидеть эффект batching: multiple oplog'ов можно объединять в одну пачку отправки.
Покрыть юнит/интег тестом: локальная запись, наличие oplog в Badger, успешная отправка синком.
Шаг B (более сложный, полноценный):
сделать прокси rueidis.Tx или унифицировать интерфейс так, чтобы текущий txf можно было выполнить и в локальном контексте (записывая в recordingTxn) — тогда все существующие транзакции автоматически запишутся локально.
реализовать WATCH/MULTI/EXEC или разрешённую схему конфликтного разрешения при применении oplog'ов (если нужны семантики атомарности).
полноценный объединитель oplog'ов, coalescing для HINCRBY/HSET и smart grouping MSET/HMSET, adaptive batching (использовать уже имеющиеся параметры batchSize, batchBytes, flushInterval).
обработка ошибок/реплеев с backoff.
Конкретные изменения кода (файлы, которые надо править)

rueidis.go:
metaOp — добавить поле Field string (для HSET) если потребуется.
txnWithWriteBack — переписать на локально-первую модель (см. выше).
runSyncWorker / syncOplog — реализовать сборку пачек и отправку в Redis (пул, pipeline, HMSET/MSET).
Возможно: tkv.go — ничего не менять (интерфейс tkvClient.txn уже позволяет атомарно применить локальную транзакцию и получить kvTxn внутри функции).
Добавить тест(ы) в pkg/meta/*_test.go для сценария fast-meta: write small file metadata, проверить что:
операции попадают в локальную БД,
oplog формируется и ставится в очередь,
sync worker группой отправляет их в Redis (можно мокать Rueidis во время теста).